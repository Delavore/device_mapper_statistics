# Что такое Device Mapper 
Device mapper - это обертка для блочных устройств, которая берет их логику и добаляет к ней свои функции. Таким образом, объединяя два устройства: исходное и device mapper target - мы получаем новое. Зачем это нужно, почему бы не создавать каждое новое устройство заново без этой прослойки? Это может быть удобно, если мы хотим применить определенный функционал к нескольким устройствам. Без этой прослойки нам надо было бы каждый раз копировать одинаковый код в наши драйвера, модули, тем самым усложняя его, и лишая модульности. Например ядро Линукс предоствляет нам набор страндатных таргетов, среди которых есть crypt - шифрование блочного утсройства, linear - сопоставление блоков одного устройтва на к блокам другого устройства, есть raid таргеты и другие. Как видно, эти стандартные таргеты может применить пользователь для своих нужд. Например LVM (LVM2) - сделана именно на основе device mapper. Если нам не достаточно стандартных таргетов, то мы можем создать свой новый таргет. 
Именно это и сделаем далее. Сделаем таргет, котырый ведет статистику о количестве операций на запись и чтение к нашим утсройсвам. Посмотреть статистику сможем через нитерфейс sysfs. 

# Реализация собственного device mapper с sysfs интерфейсом
Сначало реализуем device mapper target, а затем добавим к нему sysfs интерфейс.

## Реализация device mapper 


## Реализация sysfs интерфейса
В ходе реализации sysfs интерфейса я столкнулся с некоторыми сложностями, а именно: ипользование kobject_create_and_add или kobject_init_and_add. Изначально я реализовал всю логику через kobject_create_and_add - данной функции можно не передавать kobj_type в качестве параметра, потому что она может взять kobj_type по умолчанию. И все было бы хорошо, но только эта функция принимает указатель на kobject, а у меня kobject был вложенной структурой в private_dmp_target - структуре, которая хранит информацию о каждом устройстве. А указателем я его не мог  сделать, потому что тогда бы не смог использовать макрос container_of, который требует, чтобы поле было не указателем. Таким образом, я отказался от функции kobject_create_and_add в пользу kobject init_and_add, которая требует немного другую реализацию. Для этой функции надо явно создать kobj_type структуру, и в ней задать необходимые свойства и атрибуты. При таком подходе нам уже не нужны макрос __ATTR и функция `sysfs_create_file`. 
В итоге получаем такую структуру sysfs: 
